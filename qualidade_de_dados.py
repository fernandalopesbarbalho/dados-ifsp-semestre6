# -*- coding: utf-8 -*-
"""Aula 080. Qualidade de dados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rKEEqtmje6ptrYgy6DZsTwXJOaTejW06

# Importação de bibliotecas
"""

# @title Importe neste parágrafo as bibliotecas

import pandas as pd
import numpy as np
from scipy import stats

"""# Dados utilizados

Utilize os dados disponíveis no arquivo [Municípios brasileiros](https://drive.google.com/file/d/1zGLZDhikT0DP9DWewqBdlbhCk-lIA-Ll/view?usp=sharing).

**Descrição dos dados**:

* **CITY**: Nome do município.
* **STATE**: Nome do estado.
* **CAPITAL**: Indicação se o município é capital do seu estado.
* **REGION**: Nome da região brasileira onde o município se encontra.
* **POPULATION_2010**: População estimada daquele município em 2010.
* **POPULATION_2018**: População estimada daquele município em 2018.
* **COMP_TOT**: Número de empresas registradas atuando no município em 2016.
* **LAT**: Latitude do município.
* **LONG**: Longitude do município.
* **ALT**: Altitude do município.
* **AREA**: Área do município em quilômetros quadrados.
* **IDHM**: Índice de Desenvolvimento Humano Municipal em 2010.
* **GDP**: Produto Interno Bruto do município em 2016.
* **GDP_CAPITA**: Produto Interno Bruto per capita do município em 2016.
* **TAXES**: Valor de impostos arrecadados em 2016.
* **MUN_EXPENDT**: Valor declarado de gastos do município.
* **PLATED_AREA**: Área plantada em hectares no município.
* **GVA_AGROPEC**: Valor agregado bruto referente às atividades agropecuárias.
* **RURAL_URBAN**: Tipologia do município atribuída pelo IBGE em 2016.
* **WHELEED_TRACTOR**: Número de tratores registrados no município em 2019.

# Carga dos dados dos municípios brasileiros
"""

# @title Montar o Google Drive

from google.colab import drive
drive.mount('/content/drive')

file_path = '/content/drive/MyDrive/Colab Notebooks/BRAZIL_CITIES.csv';

# @title Criar o dataframe

df_brasil = pd.read_csv(file_path, sep= ';', decimal=",");

"""# Valores Ausentes

## Técnicas para Lidar com Ausência de Dados
"""

# @title Identificar dados ausentes no dataframe

print(df_brasil.isnull().sum())

"""### Remoção de Objetos"""

# @title Remover objetos com valor ausente em qualquer atributo preditivo;

df_qualquer = df_brasil.dropna(how='any')
print(df_qualquer.isnull().sum())

# @title Remover objetos com valor ausente em todos os atributos preditivos

df_todos = df_brasil.dropna(how='all')
print(df_todos.isnull().sum())

# @title Remover objetos com valor ausente em qualquer dos atributos preditivos selecionados: 'CITY', 'STATE'

df_selecionados = df_brasil.dropna(subset=['CITY', 'STATE'])
print(df_selecionados.isnull().sum())

# @title Remover objetos com valor ausente em todos os atributos preditivos selecionados: 'CITY', 'STATE'

df_selecionados_todos = df_brasil.dropna(subset=['CITY', 'STATE'], how='all')
print(df_selecionados_todos.isnull().sum())

"""### Remoção de Atributos Preditivos"""

# @title Remover atributo preditivo com valor ausente em qualquer objeto. Remove colunas onde há pelo menos um valor ausente.

df_qualquer_objeto = df_brasil.dropna(axis=1)
print(df_qualquer_objeto.isnull().sum())

# @title Remover atributo preditivo com valor ausente em um número determinado de objetos. O parâmetro thresh especifica o número mínimo de valores válidos que uma coluna deve ter para ser mantida.

df_numero_determinado = df_brasil.dropna(thresh=10)
print(df_numero_determinado.isnull().sum())

"""### Preenchimento de Valores"""

# @title Preencher os atributos com valor ausente com um valor constante igual a 0 (zero)

df_zero = df_brasil.fillna(0)
print(df_zero.isnull().sum())

# @title Preencher os valores faltantes da coluna IBGE_RES_POP com a média da própria coluna

df_media = df_brasil.copy()
df_media['IBGE_RES_POP'] = df_media['IBGE_RES_POP'].fillna(df_media['IBGE_RES_POP'].mean())
print(df_media.isnull().sum())

# @title Preencher os valores faltantes da coluna IBGE_RES_POP com a mediana da própria coluna

df_mediana = df_brasil.copy()
df_mediana['IBGE_RES_POP'] = df_mediana['IBGE_RES_POP'].fillna(df_mediana['IBGE_RES_POP'].median())
print(df_mediana.isnull().sum())

# @title Preencher os valores faltantes da coluna IBGE_RES_POP com a moda da própria coluna

df_moda = df_brasil.copy()
df_moda['IBGE_RES_POP'] = df_moda['IBGE_RES_POP'].fillna(df_moda['IBGE_RES_POP'].mode()[0])
print(df_moda.isnull().sum())

# @title Preencher os valores faltantes dos atributos com os valores do próximo exemplo/objeto

df_proximo = df_brasil.bfill()
print(df_proximo.isnull().sum())

"""# Valores Redundantes"""

# @title Encontrar dados duplicados

df_duplicados = df_brasil[df_brasil.duplicated()]
print(df_duplicados)

# @title Especificar a coluna que deseja encontrar dados duplicados: "IBGE_RES_POP", "AREA"

df_duplicados_coluna = df_brasil[df_brasil.duplicated(subset=['IBGE_RES_POP', 'AREA'])]
print(df_duplicados_coluna)

# @title Apresentar os dados duplicados

df_duplicados_apresentar = df_brasil[df_brasil.duplicated(keep=False)]
print(df_duplicados_apresentar)

# @title Contar dados duplicados

df_duplicados_contar = df_brasil.duplicated().sum()
print(df_duplicados_contar)

# @title Remover dados duplicadas

df_sem_duplicados = df_brasil.drop_duplicates()
print(df_sem_duplicados)

# @title Remover dados duplicados de uma coluna específica: AREA

df_sem_duplicados_coluna = df_brasil.drop_duplicates(subset=['AREA'])
print(df_sem_duplicados_coluna)

"""# Valores *Outliers*"""

# @title Identificar outliers por meio do zscore das colunas numéricas

z_scores = np.abs(stats.zscore(df_brasil.select_dtypes(include=[np.number])))
outliers = (z_scores > 3).sum(axis=1)
df_outliers = df_brasil[outliers > 0]
print(df_outliers)